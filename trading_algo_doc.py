# -*- coding: utf-8 -*-
"""Trading algo doc.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JaaCZKs0FEK33OP5aeNMHLWbv57QgJC4

<p style="color:#4B0082; font-size:200%; font-weight:bold;">
Algorithmic Trading Assignment — Louis Delacour Lucas Moerlen
</p>

<p style="color:#4B0082; font-size:120%;">
In this assignment, we will explore how to find data, manage it, test algorithmic trading techniques, and plot our findings.

<p style="color:red; font-weight:bold; font-size:300%;">
Please do not use the code blocks to run tests — they are for documentation purposes only and not meant for execution.  
Triggering them could block our API access. Thank you!
</p>

<p style="color:#4B0082; font-size:150%; font-weight:bold;">
1. We will start by selecting our tickers, which we will retrieve using a web-scraping method directly from Wikipedia.
</p>
"""

import pandas as pd

url = "https://en.wikipedia.org/wiki/Dow_Jones_Industrial_Average"
tables = pd.read_html(url)

dow_jones_table = None
for table in tables:
    if 'Symbol' in table.columns:
        dow_jones_table = table
        break

if dow_jones_table is not None:
    tickers = dow_jones_table['Symbol'].tolist()
    print("Dow Jones Tickers:", tickers)

    tickers_df = pd.DataFrame(tickers, columns=['Ticker'])
    tickers_df.to_csv('dow_jones_tickers.csv', index=False)
    print("\nTickers saved to 'dow_jones_tickers.csv'.")
else:
    print("Unable to find the Dow Jones components table.")

"""<p style="color:#4B0082; font-size:150%; font-weight:bold;">
2. We will now retrieve this week's news related to the Dow Jones thanks to <code>gnews</code> API, which we will later use to perform sentiment analysis.
</p
"""

!pip install gnews
!pip install textblob
from gnews import GNews
from textblob import TextBlob

google_news = GNews(language='en', country='US', period='1d')

news_results = google_news.get_news('finance USA')

positive, negative, neutral = 0, 0, 0

for article in news_results:
    title = article['title']
    analysis = TextBlob(title)
    polarity = analysis.sentiment.polarity

    if polarity > 0.1:
        positive += 1
    elif polarity < -0.1:
        negative += 1
    else:
        neutral += 1

    print(f"{title} --> Polarity: {polarity:.2f}")

total = positive + negative + neutral
print(f"\nResults on {total} news articles:")
print(f"Positive: {positive}")
print(f"Negative: {negative}")
print(f"Neutral: {neutral}")

if neutral > (positive + negative):
    print("\nOverall Sentiment: NEUTRAL - no significant risk.")
elif positive > negative:
    print("\nOverall Sentiment: POSITIVE. ;)")
elif negative > positive:
    print("\nOverall Sentiment: NEGATIVE. :'(")
else:
    print("\nOverall Sentiment: NEUTRAL. -_-")

"""<p style="color:#4B0082; font-size:150%; font-weight:bold;">
3. We will now retrieve the 30 Dow Jones tickers to compare their return and volatility, in order to select only 10 of them (since the APIs we will use are limited, we aim to avoid overloading them). For this, we will use <code>yfinance</code>.
</p>

"""

import yfinance as yf

def get_user_input_dates():
    start_date = input("Entrez la date de début (format: YYYY-MM-DD) : ")
    end_date = input("Entrez la date de fin (format: YYYY-MM-DD) : ")
    return start_date, end_date

df = pd.read_csv("dow_jones_tickers.csv")

tickers = df['Ticker'].tolist()

start_date, end_date = get_user_input_dates()
data = yf.download(tickers, start=start_date, end=end_date)['Close']

returns_1m = data.pct_change(periods=21).iloc[-1] * 100
returns_1y = data.pct_change(periods=252).iloc[-1] * 100

volatility_1m = data.pct_change().rolling(window=21).std().iloc[-1] * 100
volatility_1y = data.pct_change().rolling(window=252).std().iloc[-1] * 100

returns_data = pd.DataFrame({
    'Ticker': tickers,
    '1 Month Return (%)': returns_1m,
    '1 Year Return (%)': returns_1y
})

volatility_data = pd.DataFrame({
    'Ticker': tickers,
    '1 Month Volatility (%)': volatility_1m,
    '1 Year Volatility (%)': volatility_1y
})


returns_data = returns_data.set_index('Ticker')
volatility_data = volatility_data.set_index('Ticker')


merged_df = pd.merge(returns_data, volatility_data, on='Ticker')

top_10 = merged_df.sort_values(by=['1 Month Return (%)', '1 Year Return (%)'], ascending=False).head(10)

top_10.to_csv('top_10_stocks.csv')
print("Merged DataFrame:\n", merged_df)
print("\nTop 10 stocks based on return and volatility:\n", top_10)

"""<p style="color:#4B0082; font-size:150%; font-weight:bold;">
4. We use the Stock Data and Alpha Vantage APIs to retrieve intraday data. We rely on both because if we exhaust the daily quota on one, we can switch to the other.
</p>

"""

from alpha_vantage.timeseries import TimeSeries
import pandas as pd
import requests
import time

alpha_key = 'RRX41GFUX011BIA6'
stockdata_key = 'JiAuPr73vF9qfjeFlWvM64oAjEV0wslO3GoPnOUw'

tickers_df = pd.read_csv('top_10_stocks.csv')
tickers = tickers_df['Ticker'].tolist()
tickers = [ticker.replace('.', '-') for ticker in tickers]

ts = TimeSeries(key=alpha_key, output_format='pandas')

def get_intraday_data_alpha(ticker):
    try:
        data, _ = ts.get_intraday(symbol=ticker, interval='60min', outputsize='compact')
        return data
    except Exception as e:
        if "call frequency" in str(e).lower():
            raise RuntimeError("Alpha Vantage daily limit reached")
        print(f"Alpha Vantage error for {ticker}: {e}")
        return None

def get_intraday_data_stockdata(ticker):
    try:
        url = f"https://api.stockdata.org/v1/data/intraday?symbols={ticker}&interval=1h&api_token={stockdata_key}"
        response = requests.get(url)
        json_data = response.json()

        if 'data' not in json_data or not json_data['data']:
            print(f"No data returned from StockData for {ticker}")
            return None

        df = pd.DataFrame(json_data['data'][0]['values'])
        df['datetime'] = pd.to_datetime(df['datetime'])
        df.set_index('datetime', inplace=True)
        df = df.sort_index()
        return df
    except Exception as e:
        print(f"StockData error for {ticker}: {e}")
        return None

all_data = {}

for ticker in tickers:
    print(f"\nFetching data for {ticker}...")

    try:
        data = get_intraday_data_alpha(ticker)
    except RuntimeError:
        print("Alpha Vantage limit reached. Switching to StockData.org.")
        data = get_intraday_data_stockdata(ticker)

    if data is not None:
        all_data[ticker] = data
        print(f"Data for {ticker} fetched successfully.")
    else:
        print(f"Failed to fetch data for {ticker}.")

    time.sleep(13)


for ticker, data in all_data.items():
    data.to_csv(f"{ticker}_intraday_data.csv")
    print(f"Saved intraday data for {ticker} to CSV.")

print("\nLast intraday closing prices:")
for ticker, data in all_data.items():
    last_close = float(data.iloc[-1]['close'] if 'close' in data.columns else data.iloc[-1]['4. close'])
    print(f"{ticker}: {last_close}")

"""<p style="color:#4B0082; font-size:150%; font-weight:bold;">
5. To enhance the visual side of our project, we will use the Wikipedia API to retrieve descriptions of the selected tickers.
</p>

"""

import yfinance as yf
import wikipedia
import pandas as pd
from wikipedia.exceptions import DisambiguationError, PageError

def get_wikipedia_description(ticker: str, sentences: int = 2):
    try:
        stock = yf.Ticker(ticker)
        info = stock.info
    except:
        return None

    if not isinstance(info, dict) or not info:
        return None

    company_name = info.get("longName") or info.get("shortName")
    if not company_name:
        return None

    try:
        search_results = wikipedia.search(company_name)
    except:
        return None

    if not search_results:
        return None

    page_title = search_results[0]
    try:
        return wikipedia.summary(page_title, sentences=sentences)
    except (DisambiguationError, PageError, Exception):
        return None

tickers_df = pd.read_csv('top_10_stocks.csv')
tickers = tickers_df['Ticker'].tolist()

for ticker in tickers:
    desc = get_wikipedia_description(ticker)
    print(f"{ticker}: {desc or 'No description available.'}\n")

"""<p style="color:#4B0082; font-size:150%; font-weight:bold;">
✅ We have now completed the data fetching phase. All further data-related work will be based on this structure, and we can simply adjust the date ranges if needed. Let's now move on to algorithmic trading!
</p>

<p style="color:#4B0082; font-size:150%; font-weight:bold;">
6. We now move on to algorithmic trading using the following strategies: Momentum Volatility Strategy, RSI Strategy, and Moving Average Crossover Strategy And of course we are going to Back test it, we will compare them to the Basic : Buy and Hold Strategy.
</p>
"""

def moving_average_crossover_strategy(data, short_window=50, long_window=200):
    """
    Generates trading signals based on Moving Average Crossover

    Args:
        data (pandas.DataFrame): DataFrame containing price data
        short_window (int): Short-term moving average window
        long_window (int): Long-term moving average window

    Returns:
        pandas.Series: Series of trading signals (1 for buy, -1 for sell, 0 for hold)
    """
    if data is None or data.empty:
        return None

    if isinstance(data.columns, pd.MultiIndex):
        close_prices = data['Close'].iloc[:, 0]
    else:
        close_prices = data['Close'] if 'Close' in data.columns else data

    short_ma = close_prices.rolling(window=short_window).mean()
    long_ma = close_prices.rolling(window=long_window).mean()

    signals = pd.Series(0, index=close_prices.index)
    signals[short_ma > long_ma] = 1.0
    signals[short_ma < long_ma] = -1.0
    signals.iloc[:long_window] = 0.0

    return signals

def rsi_strategy(data, window=14, oversold=30, overbought=70):
    """
    Generates trading signals based on Relative Strength Index (RSI)

    Args:
        data (pandas.DataFrame): DataFrame containing price data
        window (int): RSI calculation window
        oversold (int): Oversold threshold
        overbought (int): Overbought threshold

    Returns:
        pandas.Series: Series of trading signals (1 for buy, -1 for sell, 0 for hold)
    """
    if data is None or data.empty:
        return None

    # Extract close prices
    if isinstance(data.columns, pd.MultiIndex):
        close_prices = data['Close'].iloc[:, 0]  # First ticker
    else:
        close_prices = data['Close'] if 'Close' in data.columns else data

    delta = close_prices.diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=window).mean()
    avg_loss = loss.rolling(window=window).mean()

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    signals = pd.Series(0, index=close_prices.index)
    signals[rsi < oversold] = 1.0  # Buy when oversold
    signals[rsi > overbought] = -1.0  # Sell when overbought

    signals.iloc[:window] = 0.0

    return signals

def momentum_volatility_strategy(data, roc_window=126, vol_window=20, roc_threshold=0.05, vol_percentile=75):
    """
    Generates trading signals based on momentum and volatility filters

    Args:
        data (pandas.DataFrame): DataFrame containing price data
        roc_window (int): Period for Rate of Change calculation
        vol_window (int): Period for volatility calculation
        roc_threshold (float): Threshold for Rate of Change to trigger signals
        vol_percentile (int): Percentile of volatility to use as filter

    Returns:
        pandas.Series: Series of trading signals (1 for buy, -1 for sell, 0 for hold)
    """
    if data is None or data.empty:
        return None

    df = data.copy()

    if isinstance(df.columns, pd.MultiIndex):
        close_prices = df['Close'].iloc[:, 0]  # First ticker
        high_prices = df['High'].iloc[:, 0]
        low_prices = df['Low'].iloc[:, 0]
    else:
        close_prices = df['Close'] if 'Close' in df.columns else df
        high_prices = df['High'] if 'High' in df.columns else close_prices
        low_prices = df['Low'] if 'Low' in df.columns else close_prices

    roc = close_prices.pct_change(periods=roc_window)

    high_low = high_prices - low_prices
    high_close = abs(high_prices - close_prices.shift(1))
    low_close = abs(low_prices - close_prices.shift(1))
    tr = pd.DataFrame({'high_low': high_low, 'high_close': high_close, 'low_close': low_close}).max(axis=1)
    atr = tr.rolling(window=vol_window).mean()
    volatility = atr / close_prices

    vol_threshold = volatility.quantile(vol_percentile / 100)

    signals = pd.Series(0.0, index=df.index)

    for i in range(max(roc_window, vol_window), len(df)):
        idx = df.index[i]
        roc_val = roc.iloc[i]
        vol_val = volatility.iloc[i]

        if vol_val <= vol_threshold:
            if roc_val > roc_threshold:
                signals.iloc[i] = 1.0  # Long
            elif roc_val < -roc_threshold:
                signals.iloc[i] = -1.0  # Short

    return signals

def backtest_strategy(data, signals, initial_capital=10000.0, position_size=1.0):
    """
    Backtests a trading strategy based on generated signals

    Args:
        data (pandas.DataFrame): DataFrame containing price data
        signals (pandas.Series): Series of trading signals
        initial_capital (float): Initial capital for the backtest
        position_size (float): Position size as a fraction of capital

    Returns:
        dict: Dictionary containing backtest results
    """
    if data is None or data.empty or signals is None:
        return None

    if isinstance(data.columns, pd.MultiIndex):
        close_prices = data['Close'].iloc[:, 0]  # First ticker
    else:
        close_prices = data['Close'] if 'Close' in data.columns else data

    backtest = pd.DataFrame(index=signals.index)
    backtest['price'] = close_prices
    backtest['signal'] = signals

    backtest['returns'] = backtest['price'].pct_change()

    backtest['strategy_returns'] = backtest['signal'].shift(1) * backtest['returns']

    backtest['equity_curve'] = (1 + backtest['strategy_returns']).cumprod() * initial_capital

    backtest['buy_hold_equity'] = (1 + backtest['returns']).cumprod() * initial_capital

    total_return = (backtest['equity_curve'].iloc[-1] / initial_capital - 1) * 100
    buy_hold_return = (backtest['buy_hold_equity'].iloc[-1] / initial_capital - 1) * 100

    sharpe_ratio = backtest['strategy_returns'].mean() / backtest['strategy_returns'].std() * np.sqrt(252) if backtest['strategy_returns'].std() > 0 else 0
    max_drawdown = (backtest['equity_curve'] / backtest['equity_curve'].cummax() - 1).min()

    backtest['position_change'] = backtest['signal'].diff()

    buys = backtest[backtest['position_change'] > 0].copy()
    sells = backtest[backtest['position_change'] < 0].copy()

    trades = pd.DataFrame({
        'date': list(buys.index) + list(sells.index),
        'price': list(buys['price']) + list(sells['price']),
        'type': ['buy'] * len(buys) + ['sell'] * len(sells)
    })

    trades = trades.sort_values('date').reset_index(drop=True)

    results = {
        'equity_curve': backtest['equity_curve'],
        'buy_hold_equity': backtest['buy_hold_equity'],
        'total_return': total_return,
        'buy_hold_return': buy_hold_return,
        'sharpe_ratio': sharpe_ratio,
        'max_drawdown': max_drawdown,
        'trades': trades
    }

    return results

"""<p style="color:#4B0082; font-size:150%; font-weight:bold;">
7. Next, we will handle sentiment analysis and develop strategies based on the sentiment data We will compare that with the basic : Buy and Hold strategy.
</p>

"""

def calculate_sentiment(text):
    """
    Calculates sentiment score for text using TextBlob

    Args:
        text (str): Text to analyze

    Returns:
        tuple: (polarity score, sentiment label)
    """
    analysis = TextBlob(text)
    polarity = analysis.sentiment.polarity

    if polarity > 0.1:
        sentiment = 'POSITIVE'
    elif polarity < -0.1:
        sentiment = 'NEGATIVE'
    else:
        sentiment = 'NEUTRAL'

    return polarity, sentiment

def get_market_sentiment(query='finance stock market'):
    """
    Get overall market sentiment from recent news

    Args:
        query (str): Query string for news search

    Returns:
        dict: Dictionary containing sentiment analysis results
    """
    gnews = GNews(language='en', country='US', period='1d')

    try:
        news_results = gnews.get_news(query)

        if not news_results:
            return {
                'positive': 0,
                'negative': 0,
                'neutral': 0,
                'articles': [],
                'overall': 'NEUTRAL'
            }

        positive, negative, neutral = 0, 0, 0
        analyzed_articles = []

        for article in news_results:
            title = article['title']
            polarity, sentiment_label = calculate_sentiment(title)

            if sentiment_label == 'POSITIVE':
                positive += 1
            elif sentiment_label == 'NEGATIVE':
                negative += 1
            else:
                neutral += 1

            published_date = article.get('published date', '')
            try:
                date_obj = datetime.strptime(published_date, '%a, %d %b %Y %H:%M:%S %Z')
                formatted_date = date_obj.strftime('%Y-%m-%d %H:%M')
            except (ValueError, TypeError):
                formatted_date = published_date

            analyzed_articles.append({
                'title': title,
                'publisher': article.get('publisher', {}).get('title', 'Unknown'),
                'published_date': formatted_date,
                'url': article.get('url', ''),
                'polarity': polarity,
                'sentiment': sentiment_label
            })

        overall = 'NEUTRAL'
        if neutral > (positive + negative):
            overall = 'NEUTRAL'
        elif positive > negative:
            overall = 'POSITIVE'
        elif negative > positive:
            overall = 'NEGATIVE'

        return {
            'positive': positive,
            'negative': negative,
            'neutral': neutral,
            'articles': analyzed_articles,
            'overall': overall
        }
    except Exception as e:
        print(f"Error in sentiment analysis: {e}")
        return {
            'positive': 0,
            'negative': 0,
            'neutral': 0,
            'articles': [],
            'overall': 'ERROR',
            'error': str(e)
        }

def get_stock_sentiment(ticker, company_name=None):
    """
    Get sentiment specific to a stock/company

    Args:
        ticker (str): Stock ticker
        company_name (str, optional): Company name for better news searching

    Returns:
        dict: Dictionary containing sentiment analysis results
    """
    query = f"{ticker} stock"
    if company_name:
        query = f"{company_name} {ticker} stock"

    return get_market_sentiment(query)

def optimize_sentiment_threshold(sentiment_data, price_data, num_thresholds=21):
    """
    Optimize the sentiment threshold to maximize Sharpe ratio

    Args:
        sentiment_data (pandas.Series): Series of sentiment scores
        price_data (pandas.Series): Series of price data
        num_thresholds (int): Number of evenly spaced thresholds to test

    Returns:
        dict: Dictionary with best threshold and corresponding Sharpe ratio
    """
    if sentiment_data is None or price_data is None or len(sentiment_data) < 10:
        return {'threshold': 0.1, 'sharpe': 0}

    returns = price_data.pct_change().shift(-1)

    data = pd.DataFrame({
        'sentiment': sentiment_data,
        'returns': returns
    }).dropna()

    if len(data) < 10:
        return {'threshold': 0.1, 'sharpe': 0}

    min_sentiment = data['sentiment'].min()
    max_sentiment = data['sentiment'].max()


    best = {'threshold': 0, 'sharpe': -np.inf}

    for threshold in np.linspace(min_sentiment, max_sentiment, num_thresholds):
        positions = np.where(data['sentiment'] > threshold, 1, -1)

        strategy_returns = positions * data['returns']


        if len(strategy_returns) > 1 and strategy_returns.std() > 0:
            sharpe = strategy_returns.mean() / strategy_returns.std() * np.sqrt(252)

            if sharpe > best['sharpe']:
                best = {'threshold': threshold, 'sharpe': sharpe}

    return best

def apply_sentiment_strategy(sentiment_data, price_data, threshold=None):
    """
    Apply a sentiment-based trading strategy

    Args:
        sentiment_data (pandas.Series): Series of sentiment scores
        price_data (pandas.Series): Series of price data
        threshold (float, optional): Sentiment threshold (if None, will be optimized)

    Returns:
        dict: Dictionary with strategy results
    """
    if sentiment_data is None or price_data is None or len(sentiment_data) < 10:
        return None

    # Calculate returns
    returns = price_data.pct_change()
    next_day_returns = returns.shift(-1)

    data = pd.DataFrame({
        'sentiment': sentiment_data,
        'returns': returns,
        'next_day_returns': next_day_returns
    }).dropna()

    if len(data) < 10:
        return None

    if threshold is None:
        optimized = optimize_sentiment_threshold(data['sentiment'], price_data)
        threshold = optimized['threshold']
        optimized_sharpe = optimized['sharpe']
    else:
        optimized_sharpe = None

    # Generate positions based on sentiment
    data['position'] = np.sign(data['sentiment'] - threshold)
    data['strategy_returns'] = data['position'] * data['next_day_returns']
    data['cum_strategy'] = (1 + data['strategy_returns']).cumprod()
    data['cum_buy_hold'] = (1 + data['next_day_returns']).cumprod()


    correlation = data['sentiment'].corr(data['next_day_returns'])

    if len(data) > 1:
        sharpe_strategy = data['strategy_returns'].mean() / data['strategy_returns'].std() * np.sqrt(252) if data['strategy_returns'].std() > 0 else 0
        sharpe_buy_hold = data['next_day_returns'].mean() / data['next_day_returns'].std() * np.sqrt(252) if data['next_day_returns'].std() > 0 else 0
    else:
        sharpe_strategy = 0
        sharpe_buy_hold = 0

    win_rate = (data['strategy_returns'] > 0).mean() * 100

    # Final results
    results = {
        'data': data,
        'threshold': threshold,
        'optimized_sharpe': optimized_sharpe,
        'correlation': correlation,
        'sharpe_strategy': sharpe_strategy,
        'sharpe_buy_hold': sharpe_buy_hold,
        'win_rate': win_rate,
        'cum_strategy': data['cum_strategy'],
        'cum_buy_hold': data['cum_buy_hold'],
        'total_return_strategy': (data['cum_strategy'].iloc[-1] - 1) * 100 if len(data) > 0 else 0,
        'total_return_buy_hold': (data['cum_buy_hold'].iloc[-1] - 1) * 100 if len(data) > 0 else 0
    }

    return results

def simulate_sentiment_strategy(stock_sentiment, stock_data, ticker):
    """
    Simulate a sentiment-based trading strategy

    Args:
        stock_sentiment (dict): Dictionary with stock sentiment analysis results
        stock_data (pandas.DataFrame): Stock price data
        ticker (str): Stock ticker symbol

    Returns:
        dict: Strategy simulation results
    """
    sentiment_values = [article['polarity'] for article in stock_sentiment['articles'] if 'polarity' in article]

    if not sentiment_values:
        return None

    if isinstance(stock_data.columns, pd.MultiIndex):
        price_data = stock_data.xs(ticker, axis=1, level=1)['Close']
    else:
        price_data = stock_data['Close']

    median_sentiment = np.median(sentiment_values)
    dates = price_data.index[-min(len(price_data), 30):]
    mock_sentiment = pd.Series(
        [median_sentiment + (np.random.random() - 0.5) * 0.2 for _ in range(len(dates))],
        index=dates
    )

    return apply_sentiment_strategy(mock_sentiment, price_data.loc[mock_sentiment.index])

"""<p style="color:#4B0082; font-size:200%; font-weight:bold;">
Finally, we move on to the plotting section.
</p>

<p style="color:#4B0082; font-size:150%;">
We aimed to visualize most of the key indicators used to build our strategies, as well as the results from those strategies helping us decide which one performs best and how to recalibrate the others.  
We also decided to leverage our web scraping and API data to create a brief presentation of each company.  
And as you've probably noticed by now from how everything is coded this project is designed for an interactive website focused on the 10 selected tickers! 😊 We won’t spoil everything by listing all the plots it’ll be much more enjoyable to discover them directly on the website, so don’t hesitate to keep exploring
</p>
"""

# SECTION 1: COMPANY OVERVIEW
    # ---------------------------
    st.header("Company Overview")

    company_info = results.get('company_info', {})

    if company_info:
        col1, col2 = st.columns([2, 1])

        with col1:
            # Company name and description
            st.subheader(company_info.get('name', ticker))
            st.markdown(f"**Sector:** {company_info.get('sector', 'N/A')} | **Industry:** {company_info.get('industry', 'N/A')}")

            if company_info.get('description'):
                st.markdown("### Business Description")
                st.markdown(company_info.get('description'))

            if company_info.get('wiki_description'):
                st.markdown("### From Wikipedia")
                st.markdown(company_info.get('wiki_description'))

        with col2:
            # Company metrics in a nice card format
            st.markdown("### Key Metrics")
            metrics_card = f"""
            * **Market Cap:** {company_info.get('market_cap', 'N/A')}
            * **P/E Ratio:** {company_info.get('pe_ratio', 'N/A')}
            * **Dividend Yield:** {company_info.get('dividend_yield', 'N/A')}
            * **52-Week High:** {company_info.get('52_week_high', 'N/A')}
            * **52-Week Low:** {company_info.get('52_week_low', 'N/A')}
            * **Website:** [{company_info.get('website', 'N/A')}]({company_info.get('website', '#')})
            """
            st.markdown(metrics_card)
    else:
        st.warning(f"Company information for {ticker} is not available.")

    # Divider
    st.markdown('<div class="section-divider"></div>', unsafe_allow_html=True)

    # SECTION 2: PRICE ANALYSIS
    # -------------------------
    st.header("Price Analysis")

    stock_data = results.get('stock_data')
    metrics_df = results.get('metrics_df')

    if stock_data is not None:
        # Create price chart
        st.subheader(f"{ticker} Stock Price")
        price_chart = plot_price_chart(stock_data, ticker)
        st.plotly_chart(price_chart, use_container_width=True)

        # Stock vs Index comparison
        st.subheader(f"{ticker} vs. Dow Jones Index")

        # Get Dow Jones data for the same period
        start_date = stock_data.index[0].strftime('%Y-%m-%d')
        end_date = stock_data.index[-1].strftime('%Y-%m-%d')
        try:
            dow_data = get_historical_data(["^DJI"], start_date, end_date)
            comparison_chart = plot_stock_vs_index(stock_data, ticker, dow_data)
            if comparison_chart:
                st.plotly_chart(comparison_chart, use_container_width=True)
            else:
                st.info("Could not create comparison chart with Dow Jones Index.")
        except Exception as e:
            st.info(f"Could not fetch Dow Jones data for comparison: {e}")

        # Metrics table if available
        if metrics_df is not None and ticker in metrics_df.index:
            st.subheader("Performance Metrics")
            ticker_metrics = metrics_df.loc[[ticker]]
            st.dataframe(ticker_metrics, use_container_width=True)

            # Create a bar chart of returns
            return_cols = [col for col in ticker_metrics.columns if 'Return' in col]
            if return_cols:
                returns_data = ticker_metrics[return_cols].T
                returns_data.columns = ['Value']

                fig = go.Figure()
                colors = ['#27AE60' if x >= 0 else '#E74C3C' for x in returns_data['Value']]

                fig.add_trace(go.Bar(
                    x=returns_data.index,
                    y=returns_data['Value'],
                    marker_color=colors
                ))

                fig.update_layout(
                    title=f"{ticker} Returns",
                    xaxis_title="Time Period",
                    yaxis_title="Return (%)",
                    template='plotly_white',
                    height=400,
                    margin=dict(l=20, r=20, t=50, b=20)
                )

                st.plotly_chart(fig, use_container_width=True)
    else:
        st.warning(f"Stock price data for {ticker} is not available for the selected date range.")

    # Divider
    st.markdown('<div class="section-divider"></div>', unsafe_allow_html=True)

    # SECTION 3: TRADING STRATEGIES
    # -----------------------------
    st.header("Trading Strategies Analysis")

    # Show results for each strategy
    strategies = [
        ('Moving Average Crossover', 'ma_strategy_results', 'Strategy crossing short and long moving averages'),
        ('RSI Strategy', 'rsi_strategy_results', 'Strategy based on Relative Strength Index overbought/oversold conditions'),
        ('Momentum Volatility Strategy', 'mom_vol_strategy_results', 'Strategy combining momentum indicators with volatility filters')
    ]

    for strategy_name, results_key, description in strategies:
        st.subheader(strategy_name)
        st.markdown(description)

        strategy_results = results.get(results_key)
        if strategy_results is not None:
            col1, col2 = st.columns(2)

            with col1:
                # Strategy metrics
                total_return = strategy_results.get('total_return', 0)
                buy_hold_return = strategy_results.get('buy_hold_return', 0)

                st.metric(
                    label="Strategy Return",
                    value=f"{total_return:.2f}%",
                    delta=f"{total_return - buy_hold_return:.2f}% vs Buy & Hold"
                )

                st.metric(
                    label="Buy & Hold Return",
                    value=f"{buy_hold_return:.2f}%"
                )

                st.metric(
                    label="Sharpe Ratio",
                    value=f"{strategy_results.get('sharpe_ratio', 0):.2f}"
                )

            with col2:
                # Strategy performance chart
                equity_chart = plot_strategy_performance(strategy_results)
                st.plotly_chart(equity_chart, use_container_width=True)
        else:
            st.warning(f"{strategy_name} results are not available.")

    # Divider
    st.markdown('<div class="section-divider"></div>', unsafe_allow_html=True)

    # SECTION 4: SENTIMENT ANALYSIS
    # ----------------------------
    st.header("Sentiment Analysis")

    # 4.1 Market Sentiment
    st.subheader("Market Sentiment")
    market_sentiment = results.get('market_sentiment')

    if market_sentiment:
        col1, col2 = st.columns(2)

        with col1:
            # Sentiment metrics
            st.metric("Positive News", market_sentiment.get('positive', 0))
            st.metric("Negative News", market_sentiment.get('negative', 0))
            st.metric("Neutral News", market_sentiment.get('neutral', 0))
            st.markdown(f"**Overall Market Sentiment:** {market_sentiment.get('overall', 'NEUTRAL')}")

        with col2:
            # Sentiment pie chart
            sentiment_pie = plot_sentiment_pie(
                market_sentiment.get('positive', 0),
                market_sentiment.get('negative', 0),
                market_sentiment.get('neutral', 0)
            )
            st.plotly_chart(sentiment_pie, use_container_width=True)

        # Recent market news
        st.markdown("### Recent Market News")
        if 'articles' in market_sentiment and market_sentiment['articles']:
            for article in market_sentiment['articles'][:5]:  # Limit to 5 articles
                with st.expander(article['title']):
                    st.markdown(f"**Publisher:** {article.get('publisher', 'Unknown')}")
                    st.markdown(f"**Published:** {article.get('published_date', 'Unknown')}")
                    st.markdown(f"**Sentiment:** {article.get('sentiment', 'NEUTRAL')} (Score: {article.get('polarity', 0):.2f})")
                    st.markdown(f"[Read article]({article.get('url', '#')})")
        else:
            st.info("No market news articles found.")
    else:
        st.warning("Market sentiment analysis is not available.")

    # 4.2 Stock-specific Sentiment
    st.subheader(f"{ticker} Sentiment Analysis")
    stock_sentiment = results.get('stock_sentiment')

    if stock_sentiment:
        col1, col2 = st.columns(2)

        with col1:
            # Sentiment metrics
            st.metric("Positive News", stock_sentiment.get('positive', 0))
            st.metric("Negative News", stock_sentiment.get('negative', 0))
            st.metric("Neutral News", stock_sentiment.get('neutral', 0))
            st.markdown(f"**Overall {ticker} Sentiment:** {stock_sentiment.get('overall', 'NEUTRAL')}")

        with col2:
            # Sentiment pie chart
            sentiment_pie = plot_sentiment_pie(
                stock_sentiment.get('positive', 0),
                stock_sentiment.get('negative', 0),
                stock_sentiment.get('neutral', 0)
            )
            st.plotly_chart(sentiment_pie, use_container_width=True)

        # Recent stock news
        st.markdown(f"### Recent {ticker} News")
        if 'articles' in stock_sentiment and stock_sentiment['articles']:
            for article in stock_sentiment['articles'][:5]:  # Limit to 5 articles
                with st.expander(article['title']):
                    st.markdown(f"**Publisher:** {article.get('publisher', 'Unknown')}")
                    st.markdown(f"**Published:** {article.get('published_date', 'Unknown')}")
                    st.markdown(f"**Sentiment:** {article.get('sentiment', 'NEUTRAL')} (Score: {article.get('polarity', 0):.2f})")
                    st.markdown(f"[Read article]({article.get('url', '#')})")
        else:
            st.info(f"No news articles found for {ticker}.")

        # 4.3 Sentiment-based Trading Strategy (if available)
        sentiment_strategy_results = results.get('sentiment_strategy_results')

        if sentiment_strategy_results:
            st.subheader("Sentiment-Based Trading Strategy")
            st.markdown("""
            This strategy uses news sentiment to make trading decisions:
            - Long position when sentiment is positive (above threshold)
            - Short position when sentiment is negative (below threshold)
            """)

            col1, col2, col3 = st.columns(3)

            with col1:
                st.metric(
                    label="Strategy Return",
                    value=f"{sentiment_strategy_results.get('total_return_strategy', 0):.2f}%",
                    delta=f"{sentiment_strategy_results.get('total_return_strategy', 0) - sentiment_strategy_results.get('total_return_buy_hold', 0):.2f}% vs Buy & Hold"
                )

            with col2:
                st.metric(
                    label="Buy & Hold Return",
                    value=f"{sentiment_strategy_results.get('total_return_buy_hold', 0):.2f}%"
                )

            with col3:
                st.metric(
                    label="Win Rate",
                    value=f"{sentiment_strategy_results.get('win_rate', 0):.2f}%"
                )

            col1, col2 = st.columns(2)

            with col1:
                st.metric(
                    label="Strategy Sharpe Ratio",
                    value=f"{sentiment_strategy_results.get('sharpe_strategy', 0):.2f}"
                )

            with col2:
                st.metric(
                    label="Sentiment-Return Correlation",
                    value=f"{sentiment_strategy_results.get('correlation', 0):.4f}"
                )

            # Plot cumulative returns if available
            if 'cum_strategy' in sentiment_strategy_results and 'cum_buy_hold' in sentiment_strategy_results:
                st.subheader("Cumulative Returns")

                fig = go.Figure()

                fig.add_trace(go.Scatter(
                    x=sentiment_strategy_results['cum_strategy'].index,
                    y=sentiment_strategy_results['cum_strategy'],
                    mode='lines',
                    name='Sentiment Strategy',
                    line=dict(color='#27AE60', width=2)
                ))

                fig.add_trace(go.Scatter(
                    x=sentiment_strategy_results['cum_buy_hold'].index,
                    y=sentiment_strategy_results['cum_buy_hold'],
                    mode='lines',
                    name='Buy & Hold',
                    line=dict(color='#2C3E50', width=2)
                ))

                fig.update_layout(
                    title=f"Sentiment Strategy vs Buy & Hold ({ticker})",
                    xaxis_title="Date",
                    yaxis_title="Growth of $1 Investment",
                    template='plotly_white',
                    height=400,
                    legend=dict(
                        orientation="h",
                        yanchor="bottom",
                        y=1.02,
                        xanchor="right",
                        x=1
                    )
                )

                st.plotly_chart(fig, use_container_width=True)

                # Add information about the sentiment threshold
                st.info(f"Optimized sentiment threshold: {sentiment_strategy_results.get('threshold', 0):.4f}")
    else:
        st.warning(f"Sentiment analysis for {ticker} is not available.")

    # Divider
    st.markdown('<div class="section-divider"></div>', unsafe_allow_html=True)

    # SECTION 5: ADVANCED VISUALIZATIONS
    # ----------------------------------
    st.header("Advanced Data Visualizations")

    # Get the data for visualizations
    if stock_data is not None:
        # Extract close prices
        if isinstance(stock_data.columns, pd.MultiIndex):
            close_prices = stock_data.xs(ticker, axis=1, level=1)['Close']
        else:
            close_prices = stock_data['Close']

        # 5.1 Return Distribution Analysis
        st.subheader("Return Distribution Analysis")

        # Let user select the return period and aggregation
        col1, col2 = st.columns(2)

        with col1:
            period_options = ["Daily", "Weekly", "Monthly", "Quarterly", "Yearly"]
            selected_period = st.selectbox("Select Return Period", period_options)

            period_map = {
                "Daily": 1,
                "Weekly": 5,
                "Monthly": 21,
                "Quarterly": 63,
                "Yearly": 252
            }
            period_days = period_map.get(selected_period, 1)

        with col2:
            display_options = ["Histogram", "Box Plot", "Monthly Heatmap"]
            display_type = st.selectbox("Select Visualization Type", display_options)

        # Calculate returns for the selected period
        returns = calculate_returns_for_period(close_prices, period_days)

        if display_type == "Histogram":
            hist_fig = plot_return_histogram(returns, ticker, selected_period)
            st.plotly_chart(hist_fig, use_container_width=True)

        elif display_type == "Box Plot":
            box_fig = plot_return_boxplot(returns, ticker)
            st.plotly_chart(box_fig, use_container_width=True)

        elif display_type == "Monthly Heatmap":
            heatmap_fig = plot_monthly_returns_heatmap(close_prices, ticker)
            st.plotly_chart(heatmap_fig, use_container_width=True)

        # 5.2 Volatility Analysis
        st.subheader("Volatility Analysis")

        # Calculate rolling volatility
        if len(close_prices) > 21:  # Need at least some data for volatility calculation
            volatility_fig = plot_rolling_volatility(close_prices, ticker)
            st.plotly_chart(volatility_fig, use_container_width=True)
        else:
            st.warning("Not enough data to calculate volatility.")

# Monte Carlo Process

# Verifying the fetched data
if data.empty:
    raise ValueError("No data retrieved. Check your connection or the symbol.")

# Extracting adjusted closing prices
prices = data["Close"].resample('YE').last().values

# Extracting years by explicitly converting index to datetime
years = [date.year for date in data.resample('YE').last().index]

# Checking if data covers at least 2 years (2019–2023 ideally)
if len(prices) < 2:
    raise ValueError("Insufficient data for simulation. At least 2 years of data are required.")

# Calculating historical returns
log_returns = np.log(prices[1:] / prices[:-1])  # Log returns
mean_return = log_returns.mean()
volatility = log_returns.std()

# Manual adjustment (if needed)
volatility_adjusted = max(volatility, 0.15)       # Set a realistic minimum volatility at 15%
mean_return_adjusted = min(mean_return, 0.1)      # Cap the average return at 10%

# Forecasting with ETS
model = ExponentialSmoothing(prices, trend='add', seasonal=None).fit()
forecast = model.forecast(5)  # Forecast for 5 periods (2025–2029)

# Forecast adjustment (cap growth)
forecast = np.clip(forecast, None, prices[-1] * 1.5)  # No more than 50% growth over the period

# Monte Carlo simulation
np.random.seed(42)
simulations = 500
forecast_years = len(forecast)
price_paths = np.zeros((simulations, forecast_years))

# Use the real 2024 price as the starting point for all paths
initial_price_2024 = prices[-1]

for i in range(simulations):
    price = initial_price_2024
    for t in range(forecast_years):
        if t == 0:
            price = initial_price_2024
        else:
            forecasted_price = forecast[t - 1]
            random_return = np.random.normal(mean_return_adjusted, volatility_adjusted)
            price = forecasted_price * (1 + random_return)
        price_paths[i, t] = price

# Monte Carlo statistics
mean_mc = price_paths.mean(axis=0)  # Average path
std_mc = price_paths.std(axis=0)    # Standard deviation

# Compare average paths to ETS forecast
above_forecast = np.sum(mean_mc > forecast)
below_forecast = np.sum(mean_mc < forecast)

# Recommendation decision
if above_forecast > below_forecast:
    recommendation = "Buy"
elif below_forecast > above_forecast:
    recommendation = "Sell"
else:
    recommendation = "Hold"

# Trend annotation for the plot
if above_forecast > below_forecast:
    trend_text = f"More paths above the forecast (above: {above_forecast}, below: {below_forecast})"
else:
    trend_text = f"More paths below the forecast (above: {above_forecast}, below: {below_forecast})"

# Plotting the results
plt.figure(figsize=(12, 7))
plt.plot(price_paths.T, color='purple', alpha=0.1)  # Monte Carlo paths
plt.plot(range(forecast_years), forecast, color='red', label='ETS Forecast (adjusted)', linewidth=2)

# Set x-axis to display future years (2025–2029)
plt.xticks(ticks=range(forecast_years), labels=[str(2025 + i) for i in range(forecast_years)])

# Annotate the general trend of the paths
plt.annotate(trend_text, xy=(0.5, 0.9), xycoords='axes fraction', fontsize=12, ha='center', color='green')

# Annotate the recommendation
plt.annotate(f"Recommendation: {recommendation}", xy=(0.5, 0.85), xycoords='axes fraction', fontsize=12, ha='center', color='blue')

plt.title('Monte Carlo Simulation with ETS Forecast')
plt.xlabel('Future Years')
plt.ylabel('Stock Price')
plt.legend()
plt.show()

# Creating a DataFrame for forecast results
forecast_years_list = [2025 + i for i in range(forecast_years)]
forecast_df = pd.DataFrame({
    'Year': forecast_years_list,
    'Price Forecast': forecast,
    'Monte Carlo Mean Path': mean_mc,
    'Monte Carlo Std Dev': std_mc,
    'Recommendation': recommendation
})

print(forecast_df)

"""<p style="color:#4B0082; font-size:150%; font-weight:bold;">
You will now see what the website looks like.  
We aimed to build an interactive platform that allows investors to understand which strategies work best for this type of asset but most importantly, to stay informed.  
Technical analysis is powerful, but it means little without fundamental analysis, which includes news, company background, and more.  
We hope this project meets your expectations. Thank you for everything! 😊
</p>

"""